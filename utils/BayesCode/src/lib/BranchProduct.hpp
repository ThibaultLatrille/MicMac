#pragma once

#include "Array.hpp"
#include "BranchArray.hpp"

/**
 * \brief The product of a BranchSelector<double> and a double
 *
 * takes two arguments: a branch array l_j and a double multiplier a, and
 * returns, for branch j, the product a * l_j.
 *
 */

class BranchProduct : public BranchSelector<double> {
  public:
    //! \brief Constructor with branch array and multiplier
    BranchProduct(const BranchSelector<double> &inbranchval, double inmulval)
        : branchval(inbranchval), mulval(inmulval), array(inbranchval.GetNbranch()) {}
    ~BranchProduct() {}

    virtual const Tree &GetTree() const override { return branchval.GetTree(); }

    virtual const double &GetVal(int index) const override {
        array[index] = mulval * branchval.GetVal(index);
        return array[index];
    }

    //! \brief specifies a new value for the multiplier
    void SetMulVal(double inmulval) { mulval = inmulval; }

  private:
    const BranchSelector<double> &branchval;
    double mulval;
    mutable std::vector<double> array;
};

/**
 * \brief The product of a BranchSelector<double> and a Selector<double>
 *
 * Takes two arguments: a BranchArray l_j and an Array r_i, and
 * returns, for branch j, and item i, the product r_i * l_j.
 *
 * Used in BranchOmegaModel: the mean of omega_gj, for gene g and branch j, is
 * equal to w_g * branchv_j
 */

class BranchProductArray : public Array<BranchProduct> {
  public:
    //! Constructor: parameterized by the branch array and array
    BranchProductArray(const BranchSelector<double> &inbranchval, const Selector<double> &insiteval)
        : branchval(inbranchval),
          siteval(insiteval),
          array(insiteval.GetSize(), (BranchProduct *)0) {
        for (int gene = 0; gene < GetSize(); gene++) {
            array[gene] = new BranchProduct(branchval, siteval.GetVal(gene));
        }
    }

    ~BranchProductArray() {
        for (int gene = 0; gene < GetSize(); gene++) { delete array[gene]; }
    }

    //! return total number of entries (number of genes)
    int GetSize() const { return siteval.GetSize(); }

    //! return total number of branches of the underlying tree
    int GetNbranch() const { return array[0]->GetNbranch(); }

    //! const access to the BranchProduct for the given gene
    const BranchProduct &GetVal(int gene) const {
        // array[gene]->SetMulVal(siteval.GetVal(gene));
        return *array[gene];
    }

    //! non-const access to the BranchProduct for the given gene
    BranchProduct &operator[](int gene) { return *array[gene]; }

    //! global update of the arrays (needs to be called each time the array has
    //! changed)
    void Update() {
        for (int gene = 0; gene < GetSize(); gene++) {
            array[gene]->SetMulVal(siteval.GetVal(gene));
        }
    }

  private:
    const BranchSelector<double> &branchval;
    const Selector<double> &siteval;
    std::vector<BranchProduct *> array;
};


/**
 * \brief The product of two BranchSelector<double>
 *
 * Takes two arguments: a BranchArray l_j and a second BranchArray r_j, and
 * returns, for branch j, the product r_j * l_j.
 *
 * Used in DatedBranchMutSel: the branch length (branch j), is
 * equal to the product of Chronogram and BranchRate (time * rate)
 */
class BranchwiseProduct : public SimpleBranchArray<double> {
  public:
    BranchwiseProduct(
        const BranchSelector<double> &infactor1, const BranchSelector<double> &infactor2)
        : SimpleBranchArray<double>(infactor1.GetTree()), factor1(infactor1), factor2(infactor2) {
        assert(factor1.GetNbranch() == factor2.GetNbranch());
        this->Update();
    }

    //! global update of the branch array
    void Update() {
        for (Tree::BranchIndex branch = 0; branch < this->GetNbranch(); branch++) {
            UpdateBranch(branch);
        }
    }

    //! local update (around a node) of the branch array
    //! Update the branch upstream (parent) and all branches downstream (children)
    void UpdateLocal(Tree::NodeIndex node) {
        // update all branch lengths around this node

        if (this->GetTree().is_root(node)) {
            Update();
        } else {
            // for all children
            for (auto &child_node : this->GetTree().children(node)) {
                UpdateBranch(this->GetTree().branch_index(child_node));
            }
            // for the branch attached to the node
            UpdateBranch(this->GetTree().branch_index(node));
        }
    }

    //! branch update (at a specific branch) of the branch array
    virtual void UpdateBranch(Tree::BranchIndex branch) {
        (*this)[branch] = factor1.GetVal(branch) * factor2.GetVal(branch);
    }

  protected:
    const BranchSelector<double> &factor1;
    const BranchSelector<double> &factor2;
};

/**
 * \brief The product of two BranchSelector<double> and division by the third BranchSelector<double>
 *
 * Takes three arguments: a BranchArray l_j, a second BranchArray r_j, a third BranchArray t_j and
 * returns, for branch j: r_j * l_j / t_j.
 *
 * Used in DatedBranchMutSel: the branch length (branch j), is
 * equal to the product of Chronogram and BranchRate divided by GenerationTime (time *
 * mutation rate / generation time)
 */
class BranchwiseProductDivision : public BranchwiseProduct {
  public:
    BranchwiseProductDivision(const BranchSelector<double> &infactor1,
        const BranchSelector<double> &infactor2, const BranchSelector<double> &infactor3)
        : BranchwiseProduct(infactor1, infactor2), factor3(infactor3) {
        assert(factor1.GetNbranch() == factor3.GetNbranch());
        this->Update();
    }

    //! branch update (at a specific branch) of the branch array
    void UpdateBranch(Tree::BranchIndex branch) override {
        (*this)[branch] = factor1.GetVal(branch) * factor2.GetVal(branch) / factor3.GetVal(branch);
    }

  private:
    const BranchSelector<double> &factor3;
};